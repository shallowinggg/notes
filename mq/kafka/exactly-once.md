---
layout: default
title: 仅一次
parent: Kafka
grand_parent: 消息队列
---

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

Kafka 中的一次性语义是两个关键功能的组合：幂等生产者（有助于避免生产者重试造成的重复）和事务语义（保证流处理应用程序中的一次性处理）。


## 幂等生产者

当我们启用幂等生产者时，每条消息都将包含一个唯一标识的生产者 ID (PID) 和一个序列号。这些与目标主题和分区一起唯一地标识每条消息。`broker`使用这些唯一标识符来跟踪`broker`上每个分区生成的最后 5 条消息。为了限制每个分区必须跟踪的先前序列号的数量，我们还要求生产者使用 `max.inflight.requests=5` 或更低（默认为 5）。

当`broker`收到一条消息表明它已经之前接受过，它将拒绝重复项并出现适当的错误。此错误由生产者记录并反映在其指标中，但不会导致任何异常，也不应引起任何警报。在生产者客户端上，它将被添加到`record-error-rate`指标中。在`broker`上，它将成为 RequestMetrics 类型的 ErrorsPerSec 指标的一部分，其中包括每种错误类型的单独计数。如果`broker`收到意外高的序列号怎么办？`broker`期望消息 2 后面跟着消息 3；如果`broker`收到 27 号消息，会发生什么情况？在这种情况下，`broker`将响应“乱序序列号”错误，但如果我们使用幂等生产者而不使用事务，则可以忽略此错误。

> 警告：虽然生产者在遇到“乱序序列号”异常后将正常继续，但此错误通常表明生产者和`broker`之间的消息丢失 ———— 如果`broker`在消息号 2 后收到消息号 27，则消息 3 到消息 26一定发生了某些情况。当在日志中遇到此类错误时，值得重新检查生产者和主题配置，并确保生产者配置了推荐值以实现高可靠性，以及检查是否发生了不干净的`Leader`选举。

### 生产者重启

当生产者发生故障时，通常会创建一个新的生产者来替换它 ———— 无论是由人工重新启动机器，还是使用更复杂的框架（例如提供自动故障恢复的 Kubernetes）。关键是，当生产者启动时，如果启用了幂等生产者，生产者将初始化并联系 Kafka Broker 以生成生产者 ID。生产者的每次初始化都会产生一个全新的 ID（假设我们没有启用事务）。这意味着，如果生产者发生故障，并且替换它的生产者发送了一条先前由旧生产者发送的消息，则`broker`将不会检测到重复项 ———— 这两个消息将具有不同的生产者 ID 和不同的序列号，并且将被视为两条不同的消息。请注意，如果旧的生产者冻结了，然后在替换开始后又复活了，情况也是如此 ———— 原始生产者不会被识别为僵尸，因为我们有两个完全不同的生产者，具有不同的 ID。

### broker失败

当`broker`发生故障时，控制器会为故障`broker`上有`Leader`的分区选举新的`Leader`。假设我们有一个生产者，它向主题 A（分区 0）生成消息，该生产者在broker 5 上有一个主副本，在broker 3 上有一个跟随副本。在broker 5 发生故障后，broker 3 成为新的`Leader`。生产者将通过元数据协议发现新的`Leader`是broker 3，并开始向其生产。但是，broker 3 如何知道已经生成了哪些序列以拒绝重复项？

每次生成新消息时，`Leader`都会使用最后五个序列 ID 更新其内存中的生产者状态。追随者副本每次从`Leader`复制新消息时都会更新自己的内存缓冲区。这意味着当追随者成为`Leader`时，它已经在内存中拥有最新的序列号，并且可以继续验证新生成的消息，而不会出现任何问题或延迟。

但是当旧的`Leader`回来时会发生什么？重新启动后，生产者状态将不再存在于内存中。为了帮助恢复，`broker`在关闭或每次创建日志段时都会将生产者状态的快照保存到文件中。当`broker`启动时，它从文件中读取最新状态。然后，重新启动的`broker`通过从当前`Leader`复制来赶上，并不断更新生产者状态，并且当它准备好再次成为`Leader`时，它在内存中具有最新的序列ID。

如果`broker`崩溃并且最后一个快照没有更新怎么办？生产者 ID 和序列 ID 也是写入 Kafka 日志的消息格式的一部分。在崩溃恢复期间，将通过读取较旧的快照以及来自每个分区的最新段的消息来恢复生产者状态。恢复过程完成后将立即存储新的快照。一个有趣的问题是如果没有消息会发生什么？想象一下，某个主题有两个小时的保留时间，但在过去两个小时内没有新消息到达 ———— 如果`broker`崩溃，将没有消息可用于恢复状态。幸运的是，没有消息也意味着没有重复。我们将立即开始接受消息（同时记录有关缺少状态的警告），并根据到达的新消息创建生产者状态。

### 限制

Kafka 的幂等生产者仅在生产者内部逻辑导致重试的情况下防止重复。使用相同的消息调用 `Producer.send()` 两次将创建重复的消息，并且幂等生产者不会阻止它。这是因为生产者无法知道发送的两个记录实际上是同一个记录。使用生产者内置的重试机制始终是一个好主意，而不是捕获生产者异常并从应用程序本身重试；幂等生产者使这种模式更具吸引力 ———— 这是重试时避免重复的最简单方法。

具有多个实例甚至一个实例具有多个生产者的应用程序也很常见。如果其中两个生产者尝试发送相同的消息，幂等生产者将不会检测到重复。这种情况在从源（例如包含文件的目录）获取数据并将其生成到 Kafka 的应用程序中相当常见。如果应用程序碰巧有两个实例读取同一文件并向 Kafka 生成记录，我们将获得该文件中记录的多个副本。

> 幂等生产者只会防止生产者本身的重试机制导致的重复，无论重试是由生产者、网络还是`broker`错误引起的。

### 使用

将`enable.idempotence=true`添加到生产者配置中。如果生产者已经配置了`acks=all`，那么性能不会有任何差异。通过启用幂等生产者，以下事情将会改变：
- 为了检索生产者ID，生产者在启动时将进行一次额外的API调用。
- 每条记录发送的批次将包括生产者 ID 和批次中第一条消息的序列 ID（批次中每条消息的序列 ID 源自第一条消息的序列 ID 加上增量）。这些新字段向每个记录批次添加 96 位（生产者 ID 是一个长整型，序列是一个整数），这对于大多数工作负载来说几乎没有任何开销。
- `broker`将验证来自任何单个生产者实例的序列号，并保证不存在重复的序列号。
- 即使 `max.in.flight.requests.per.connection` 设置为大于 1（5 是默认值，也是幂等支持的最高值，在所有故障场景中，每个分区生成的消息的顺序都会得到保证。

> 注意。由于 KIP-360，幂等生产者逻辑和错误处理在 2.5 版本中（生产者端和`broker`端）得到了显着改进。在版本 2.5 之前，生产者状态并不总是维持足够长的时间，这会在各种情况下出现致命的 `UNKNOWN_PRODUCER_ID` 错误。此外，之前的版本在某些错误情况下尝试重写序列ID，这可能会导致重复。在较新的版本中，如果我们遇到消息批次的致命错误，则该批次以及所有正在运行的批次都将被拒绝。编写应用程序的用户可以处理异常并决定是否跳过这些记录或重试并冒重复和重新排序的风险。

## 事务

Kafka 中的事务是专门为流处理应用程序开发的。因此，它们的构建是为了使用`消费-处理-生产`模式，该模式构成了流处理应用程序的基础。在这种情况下，使用事务可以保证仅一次语义 ———— 在应用程序的内部状态更新并且结果成功生成到输出主题之后，每个输入记录的处理将被视为完成。

